; ------------------------------------------------------------------
; GEMINI MEM TAG (DO NOT EVER REMOVE OR EDIT) - MY FULL PATH IS "Pipz_Project_V3\PPAVP\Policy-B Registry Audit.txt"
; ------------------------------------------------------------------

; ------------------------------------------------------------------
; MAINTEMPLATE - Policy-B Registry Audit.txt
; Version: 1.0.0
; Last change: Initial creation of Policy-B Registry Audit Checklist.
; Content-Fingerprint: 2026-01-28T23-40-57Z-3KU3H3WI
; ------------------------------------------------------------------

; ------------------------------------------------------------------
; ALL CONTENT MUST GO BELOW THIS POINT (LINES 1-14 RESERVED)
; ------------------------------------------------------------------

## Policy-B Registry Audit Checklist (repeatable)

Run this checklist **any time you change code** in these canonical files:

* `Controller/Main_Controller.ahk`
* `Controller/Controller_Core.ahk`
* `Worker/Main_Worker.ahk`
* `Worker/Worker_Core.ahk`
* `Lib/Core_Utils.ahk`
* `Lib/Interop.ahk`
* `Lib/Humanoid.ahk`

**Goal:** keep `GLOBAL_REGISTRY_MASTER.csv` authoritative for **governance-surface changes only** (entrypoints, timers, OnMessage/IPC, lifecycle, settings/defaults interface).

---

### 0) Pre-flight (scope guard)

* ✅ Confirm you are auditing **Policy-B surface only**:

  * Entrypoints / lifecycle
  * Timers
  * OnMessage handlers
  * IPC send/receive contracts
  * Settings IO + defaults interface
  * Process lifecycle controls

If you’re looking at internal helpers only → **do not touch the governed registry** (that’s what `INTERNAL_FUNCTION_INDEX.csv` is for).

---

### 1) Entrypoints audit (Controller + Worker)

For each file, scan for the following patterns and ensure every item is represented in the registry:

**Controller Entrypoints**

* `OnExit(<fn>)`
* `OnMessage(<msg>, <fn>)`
* `Gui.OnEvent("<event>", <fn>)` or `Control.OnEvent(...)`
* Initial “boot actions” that cause governance-surface effects:

  * worker warm-start calls
  * license gate call
  * settings/defaults load call

**Worker Entrypoints**

* `OnMessage(<msg>, <fn>)`
* `SetTimer(<fn>, <interval>)`
* Listener bootstrap call (e.g., `SetupWorkerListener()`)
* Main runtime loop start (Loop { ... }) — not usually a registry item by itself unless it exposes new controls

✅ Registry must list:

* **Entrypoint type** (GUI / OnMessage / OnExit / Startup)
* **Exact handler name**
* **Owner file**

---

### 2) Timers audit (SetTimer surface)

For each `SetTimer(...)` occurrence:

* Extract:

  * callback name
  * interval (or one-shot negative interval)
  * owner file
  * purpose label (“Health monitor”, “Overlay physics”, “Settings watchdog”, “Tooltip clear”, etc.)

✅ Registry must include each timer callback that is governance-surface relevant.

**Policy-B rule of thumb:** timers that:

* check settings / reload config
* monitor worker health
* move overlay
* create user-visible behavior or cross-process behavior
  → should be in the governed registry.

Timers that are purely internal math helpers → usually not.

---

### 3) OnMessage audit (IPC + OS message surface)

For each `OnMessage(MSG_ID, Handler)`:

* Record:

  * MSG_ID (hex)
  * Handler function name
  * Owner file
  * What the handler *does* at surface level

✅ Registry must include:

* message ID
* handler name
* direction (OS → controller, controller → worker, etc.)

**Mandatory ones in your system (typical):**

* `0x0200` (mouse move tooltip processing) on controller side
* `0x004A` (WM_COPYDATA title update) on worker side
* `WM_TRIGGER_STATE` (custom state signal) on worker side

---

### 4) IPC contract audit (Interop contract stability)

In `Interop.ahk`, verify:

* Custom message IDs / constants:

  * `WM_TRIGGER_STATE := 0x....`
* Encoding contract:

  * `wParam` meanings (1/0/2 etc.)
* Sender helper(s):

  * e.g., `SendWorkerSignal(state)`
* Receiver handler:

  * e.g., `Worker_ReceiveSignal(...)`

✅ Registry must reflect:

* message constant name + value
* sender function(s)
* receiver handler(s)
* encoding contract summary

**Hard-stop rule:** If encoding changes, registry update is mandatory.

---

### 5) Settings/defaults interface audit (Core_Utils surface)

In `Core_Utils.ahk`, confirm the registry includes the canonical interface:

* `GetDefaultSettings()`
* `GetSettingsPath()`
* `LoadSetting(section,key,default)`
* `SaveSetting(section,key,value)`
* `ValidateLicense(...)` (if treated as governed surface)

✅ Registry must identify:

* these as “Settings IO / Defaults Interface / Security Gate”
* the owner file `Core_Utils.ahk`

---

### 6) Lifecycle / process control audit

Scan for any function that:

* launches worker (`Run(...)`)
* monitors worker (health checks)
* kills worker (`ProcessClose(...)`)
* shuts down / exit hooks (`OnExit(...)`)

✅ Registry must include these lifecycle controls (Policy-B surface).

---

### 7) Ownership audit (no stale owner entries)

For each governed registry row:

* Confirm:

  * function exists in that file
  * name matches exactly (case-sensitive conventions you use)
  * it’s still the correct “owner” after refactors (e.g., moved into `*_Core.ahk`)

✅ If owner moved, update **owner column only** (don’t expand scope).

---

### 8) “No new surface” assertion (final check)

If code changes were intended to be internal-only:

* Confirm **no new**:

  * `OnMessage`
  * `SetTimer`
  * `OnExit`
  * process launch/kill paths
  * settings IO interface functions
  * IPC constants / senders / receivers

✅ If none added → **do not update** governed registry.

---

## Output format when something changes (use this exact mini-report)

When you find a registry-required change, write a short delta like:

* **ADD**: `OnMessage 0x1234 -> NewHandler` (Owner: `Worker_Core.ahk`) — purpose: `<…>`
* **ADD**: `SetTimer(NewTimerCb, 500)` (Owner: `Main_Worker.ahk`) — purpose: `<…>`
* **MOVE**: `UpdateWorkerOverlay` from `Main_Worker.ahk` → `Worker_Core.ahk`
* **MODIFY**: `WM_TRIGGER_STATE encoding` changed to `<…>` (requires registry update)