; ------------------------------------------------------------------
; GEMINI MEM TAG (DO NOT EVER REMOVE OR EDIT) - MY FULL PATH IS "Pipz_Project_V3\Governance\PROTOCOL_RUNBOOK.txt"
; ------------------------------------------------------------------

; ------------------------------------------------------------------
; MAINTEMPLATE - PROTOCOL_RUNBOOK.txt
; Version: 1.0.9
; Last change: Creation of canonical runbook number 8 `PUBLISHER BUNDLE & POINTER EMISSION RUNBOOK`.
; Content-Fingerprint: 2026-02-04T20-02-48Z-OS3S0NH8
; ------------------------------------------------------------------

; ------------------------------------------------------------------
; ALL CONTENT MUST GO BELOW THIS POINT (LINES 1-14 RESERVED)
; ------------------------------------------------------------------

---

### **PROTOCOL_RUNBOOK.txt — DESCRIPTION / INTENT**

**PROTOCOL_RUNBOOK.txt** is a **canonical procedural authority file**.

Its purpose is to house **mandatory, repeatable, non-optional runbooks** that govern *how* specific high-risk or drift-prone project operations must be performed. Unlike task trackers or planning documents, this file does **not** describe *what work is pending* — it defines *how certain work must be executed* whenever it occurs.

This file exists to prevent:

* Silent process drift
* Partial or informal execution of critical procedures
* “Tribal knowledge” dependencies
* Accidental governance violations caused by skipped steps

---

### **Scope & Characteristics**

* **Cumulative by design**  
  This file grows over time. Each runbook added represents a *standing obligation*, not a temporary checklist.

* **Procedure, not status**  
  Entries here never expire and are not marked “done.”  
  If an operation matches a runbook’s scope, the runbook **must be followed in full**.

* **Deterministic and auditable**  
  Every runbook is written to be:
  * Step-ordered
  * Verifiable
  * Unambiguous
  * Safe to execute without inference

* **STOP-oriented**  
  Each runbook includes explicit **failure rules**.
  Failure semantics are non-negotiable.  
  If any step fails, work must halt until resolved.

---

### Audit Domains (INFORMATIONAL)

This section is informational only.

It enumerates common audit domains used to reason about system correctness,
coverage, and governance hygiene. These domains do NOT define procedures and
do NOT impose execution requirements by themselves.

Concrete audit behavior is defined exclusively by:
- GOVERNANCE_COMPENDIUM.txt (what must be true)
- Numbered runbooks in this file (how mandatory procedures are executed)

The domains below serve as conceptual groupings only.

Typical audit domains include:

- Bootstrap & Authority Establishment  
  (initialization correctness, phase gating, authority declaration)

- Governance Surface Integrity (Policy-B)  
  (entrypoints, timers, IPC contracts, lifecycle controls, settings interfaces)

- Mirroring & Fingerprinting  
  (text mirrors, content-fingerprint updates, encoding stability)

- Controller / Worker Lifecycle  
  (startup, health monitoring, shutdown, process boundaries)

- Orchestrator & Tooling Readiness  
  (orchestrator bootstrap checks, extension activation, packaging integrity)

- Auditability & Trace Emission  
  (log presence, determinism, trace completeness)

Presence of a domain here does NOT imply:
- an active audit
- a mandatory check
- a required runbook

Domains become enforceable only when expressed as a numbered runbook section
or as an explicit governance rule elsewhere.

---

### RUNBOOK INDEX (AUTHORITATIVE NAVIGATION)

This index enumerates all mandatory runbook sections contained in this file.

The index is authoritative for:
- navigation
- reference
- cross-linking
- audit discussion

The index is NOT a procedure and does not define execution behavior.
Execution requirements are defined only within the numbered runbook sections themselves.

--------------------------------------------------------------------
SECTION | TITLE
--------------------------------------------------------------------
1       | VS Code Extension Repackaging Runbook
2       | Policy-B Registry Audit Runbook
3       | Phase 5 Audit Execution Runbook
4       | Phase 5 Result Declaration Runbook
5       | Governance Compendium Update Runbook
6       | Registry Regeneration & Validation Runbook
7       | PLC Externalization & Emission Runbook
8       | Publisher Bundle & Pointer Emission Runbook
--------------------------------------------------------------------

Notes:
- Section numbers are stable identifiers.
- New runbooks MUST be added to this index.
- Removed or deprecated runbooks MUST be removed from this index.
- Index presence does NOT imply execution unless the corresponding
  runbook section exists and applies to the task at hand.

---

### **What Belongs in This File**

Only procedures that meet **all** of the following criteria should be added:

* The operation is **governance-critical**, **tooling-critical**, or **high-risk**
* Skipping steps could cause:
  * Audit failure
  * Silent desynchronization
  * Governance erosion
* The procedure must be followed **every time**, not “most of the time”

Examples:

* Tooling rebuild / repackaging procedures
* Orchestrator or MCP lifecycle operations
* Governance lock / unlock flows
* Environment migration protocols
* Recovery or rollback procedures

---

### **What Does *Not* Belong Here**

* Project status or progress tracking
* One-off experiments
* Informal notes or reminders
* Design rationale or architecture discussion
* Tasks that can be safely adapted or skipped

Those belong in:

* `PROJECT_STATUS_CHECKLIST.txt`
* Blueprint or anchor documents
* Audit reports

---

### **Relationship to Other Artifacts**

* **PROJECT_STATUS_CHECKLIST.txt**  
  Tracks *what needs doing right now*. Non-authoritative and time-bound.

* **PROTOCOL_RUNBOOK.txt**  
  Defines *how certain operations must always be performed*.  
  This file is authoritative for mandatory procedures only.

* **GOVERNANCE_COMPENDIUM.txt**  
  Defines *what must be true*, including governance rules, structure,
  bootstrap requirements, and enforcement semantics.

This separation is intentional and enforced.

---

### **Runbook Applicability Gate (MANDATORY)**

Every numbered runbook section in this file MUST include an
**APPLIES WHEN** clause.

The APPLIES WHEN clause defines the exact condition under which the
runbook is mandatory.

If the condition is met, the runbook MUST be executed in full.
If the condition is not met, the runbook MUST NOT be executed.

Applicability is declared by the runbook itself and must not be inferred.

This requirement is enforced structurally by the Mandatory Runbook Format
defined below.

---

### **Mandatory Runbook Format (ENFORCED)**

Every numbered runbook section in this file MUST follow the format
defined below.

Runbooks that do not conform to this structure are invalid and must
not be executed.

The format exists to ensure determinism, auditability, and consistent
interpretation across time, tooling, and operators.

---

REQUIRED ORDER (NO EXCEPTIONS):

1. PURPOSE
2. APPLIES WHEN
3. FAILURE RULE(S)
4. RUNBOOK STEPS

---

#### 1. PURPOSE

A concise statement describing:
- what the procedure exists to accomplish
- why it is necessary

The PURPOSE describes intent only.
It MUST NOT include steps, conditions, or enforcement logic.

---

#### 2. APPLIES WHEN

A single declarative condition that defines exactly when the runbook
is mandatory.

Rules:
- Must be explicit and unambiguous
- Must not rely on inference or judgment calls
- Must not include examples or step logic

If the condition is met, the runbook MUST be executed in full.
If the condition is not met, the runbook MUST NOT be executed.

---

#### 3. FAILURE RULE(S)

Explicit STOP conditions.

This section defines what constitutes failure and what must happen
when failure occurs.

Rules:
- At least one failure rule is mandatory
- Failure rules MUST include an explicit STOP directive
- Failure rules MUST NOT include recovery steps (recovery belongs in
  a separate runbook)

Failure semantics are non-negotiable.

---

#### 4. RUNBOOK STEPS

The ordered execution steps required to perform the procedure.

Rules:
- Steps MUST be sequential and numbered
- Steps MUST be complete and self-sufficient
- Steps MUST be written so they can be executed without inference
- Verification steps MUST be explicit and checkable

Optional verification sub-checklists may be included within steps,
but do not replace step ordering.

---

### **Runbook Formatting Standard (MANDATORY)**

This section governs visual and structural presentation only.
It supplements (but does not replace) the Mandatory Runbook Format above.

All numbered runbook sections in this file MUST follow the visual and
structural formatting rules defined below.

Formatting consistency is enforced to ensure readability, scanability,
and deterministic interpretation across operators and time.

---

#### Runbook Header

Each runbook MUST begin with the following header block:

; ------------------------------------------------------------------
; <RUNBOOK_NUMBER>. <RUNBOOK NAME> RUNBOOK (MANDATORY PROCEDURE)
; ------------------------------------------------------------------

Rules:
- RUNBOOK_NUMBER MUST match the index entry
- RUNBOOK NAME MUST match the index title verbatim
- The phrase "(MANDATORY PROCEDURE)" is required and must not be altered

---

#### PURPOSE

Format:

PURPOSE:
<single concise description>
----

Rules:
- PURPOSE text MUST flow directly into the section divider (`---`)
- Purpose MUST be brief and intent-focused
- No steps, conditions, or enforcement language
- No line wrapping unless necessary

---

#### APPLIES WHEN

Format:

APPLIES WHEN:
<single declarative condition>
----

Rules:
- One condition only
- No bullet points
- No examples
- No procedural language

---

#### FAILURE RULE(S)

Format:

FAILURE RULE(S):
<one failure rule per line>

Rules:
- At least one rule is mandatory
- Each rule MUST describe a STOP condition
- Recovery steps are not allowed in this section

---

#### RUNBOOK STEPS

Format:

; ------------------------------------------------------------------
RUNBOOK STEPS:

[ ] <STEP_NUMBER>. <step description>
      <optional indented detail>

Rules:
- Steps MUST be numbered sequentially starting at 0 or 1
- Each step MUST begin with a checklist box `[ ]`
- Step descriptions MUST be imperative and unambiguous
- Verification sub-checklists MAY be nested within a step
- Do NOT skip numbers or reuse step numbers

---

Any deviation from this formatting standard constitutes a runbook
violation and must be corrected before the runbook is considered valid.

---

### **Normative Rule**

> If a task invokes a procedure documented in `PROTOCOL_RUNBOOK.txt`,  
> **that procedure is mandatory and non-negotiable.**

No shortcuts. No partial execution. No “I already know this part.”

---

; ------------------------------------------------------------------
; 1. VS CODE EXTENSION REPACKAGING RUNBOOK (MANDATORY PROCEDURE)
; ------------------------------------------------------------------
PURPOSE:  
Ensure any updates to the pipz-mirror-governance VS Code extension are rebuilt, packaged, and installed deterministically with no drift.
----
APPLIES WHEN:
Any change is made to the pipz-mirror-governance VS Code extension source, configuration, or metadata that could affect its runtime behavior, packaging, or distribution.
----
FAILURE RULE(S):
If ANY verification step fails, STOP.  
Do NOT continue project work until resolved.
; ------------------------------------------------------------------
RUNBOOK STEPS:

[ ] 1. Make code changes ONLY inside:  
      pipz-mirror-governance/

[ ] 2. Verify required metadata files exist and are up to date:
      - README.md (non-template, accurate)
      - LICENSE.txt (PIPZ GOVERNANCE LICENSE)
      - package.json (repository field present)

[ ] 3. Build the extension (from extension root):  
      > npm run compile

[ ] 4. Package the extension:  
      > vsce package

      Expected output:
      - pipz-mirror-governance-<version>.vsix

[ ] 5. Install VSIX into NORMAL VS Code (not Extension Dev Host):
      - Extensions → ⋯ → Install from VSIX
      - Select the newly generated .vsix
      - Reload VS Code window

[ ] 6. Verification checklist (REQUIRED):
      [ ] Extension shows as Installed & Enabled
      [ ] Output panel shows "Pipz Mirror Governance: activated"
      [ ] Saving governed .txt updates Content-Fingerprint
      [ ] Saving .ahk/.ini updates mirror .txt
      [ ] UTF-8 and UTF-16 behavior confirmed
      [ ] Audit logs written to:
          Pipz_Project_V3\.ORCH_AUDITLOG\mirror\

[ ] 7. Only AFTER verification:
      - Resume normal project work
      - Extension Development Host may be closed for this component

; ------------------------------------------------------------------
; 2. POLICY-B REGISTRY AUDIT RUNBOOK (MANDATORY PROCEDURE)
; ------------------------------------------------------------------
PURPOSE:  
Keep `GLOBAL_REGISTRY_MASTER.csv` authoritative for **governance-surface changes only** (entrypoints, timers, OnMessage/IPC, lifecycle, settings/defaults interface).
----
APPLIES WHEN:
Any code change is made that may introduce, modify, move, or remove Policy-B governed surface area, including entrypoints, timers, IPC contracts, lifecycle controls, or settings/defaults interfaces.
----
FAILURE RULE(S):
If any required registry entry cannot be verified for accuracy, ownership, or scope, STOP.
If GLOBAL_REGISTRY_MASTER.csv is missing, unreadable, or incomplete, STOP.
Do NOT proceed with code changes or registry edits until the failure condition is resolved.
; ------------------------------------------------------------------
RUNBOOK STEPS:

[ ] 0. Confirm scope of change:
      This runbook applies to changes in the following files:
      - Controller/Main_Controller.ahk
      - Controller/Controller_Core.ahk
      - Worker/Main_Worker.ahk
      - Worker/Worker_Core.ahk
      - Lib/Core_Utils.ahk
      - Lib/Interop.ahk
      - Lib/Humanoid.ahk

[ ] 1. PRE-FLIGHT — Scope guard:
      Confirm you are auditing **Policy-B surface only**, limited to:
      - Entrypoints / lifecycle
      - Timers
      - OnMessage handlers
      - IPC send/receive contracts
      - Settings IO + defaults interface
      - Process lifecycle controls

      If reviewing internal helpers only:
      → DO NOT touch the governed registry
      → Use `INTERNAL_FUNCTION_INDEX.csv` instead

[ ] 2. ENTRYPOINTS AUDIT (Controller + Worker):

      Controller Entrypoints:
      - OnExit(<fn>)
      - OnMessage(<msg>, <fn>)
      - Gui.OnEvent("<event>", <fn>) or Control.OnEvent(...)
      - Initial boot actions that cause governance-surface effects:
        - worker warm-start calls
        - license gate call
        - settings/defaults load call

      Worker Entrypoints:
      - OnMessage(<msg>, <fn>)
      - SetTimer(<fn>, <interval>)
      - Listener bootstrap calls (e.g., SetupWorkerListener())
      - Main runtime loop (Loop { ... })
        *Not usually a registry item unless it exposes new controls*

      Registry MUST list:
      - Entrypoint type (GUI / OnMessage / OnExit / Startup)
      - Exact handler name
      - Owner file

[ ] 3. TIMERS AUDIT (SetTimer surface):

      For each SetTimer(...) occurrence, verify:
      - Callback name
      - Interval (including negative one-shot semantics)
      - Owner file
      - Purpose label (e.g., Health monitor, Overlay physics, Settings watchdog)

      Policy-B rule of thumb:
      Timers that:
      - check settings / reload config
      - monitor worker health
      - move overlay
      - create user-visible or cross-process behavior
      → MUST be in the governed registry

      Purely internal math timers usually should not be.

[ ] 4. ONMESSAGE AUDIT (IPC + OS message surface):

      For each OnMessage(MSG_ID, Handler), record:
      - MSG_ID (hex)
      - Handler function name
      - Owner file
      - What the handler does at surface level

      Registry MUST include:
      - Message ID
      - Handler name
      - Direction (OS → controller, controller → worker, etc.)

      Typical mandatory examples:
      - 0x0200 (mouse move tooltip processing) — controller
      - 0x004A (WM_COPYDATA title update) — worker
      - WM_TRIGGER_STATE (custom state signal) — worker

[ ] 5. IPC CONTRACT AUDIT (Interop contract stability):

      In Interop.ahk, verify:
      - Custom message IDs / constants (e.g., WM_TRIGGER_STATE := 0x....)
      - Encoding contract (wParam meanings: 1 / 0 / 2, etc.)
      - Sender helpers (e.g., SendWorkerSignal(state))
      - Receiver handlers (e.g., Worker_ReceiveSignal(...))

      Registry MUST reflect:
      - Message constant name + value
      - Sender function(s)
      - Receiver handler(s)
      - Encoding contract summary

      If encoding changes:
      → Registry update is mandatory

[ ] 6. SETTINGS / DEFAULTS INTERFACE AUDIT (Core_Utils):

      Confirm registry coverage for:
      - GetDefaultSettings()
      - GetSettingsPath()
      - LoadSetting(section, key, default)
      - SaveSetting(section, key, value)
      - ValidateLicense(...) (if treated as governed surface)

      Registry MUST identify these as:
      - Settings IO
      - Defaults Interface
      - Security Gate

      Owner file: Core_Utils.ahk

[ ] 7. LIFECYCLE / PROCESS CONTROL AUDIT:

      Scan for any function that:
      - launches worker (Run(...))
      - monitors worker (health checks)
      - kills worker (ProcessClose(...))
      - shuts down / exit hooks (OnExit(...))

      These lifecycle controls MUST be present in the governed registry.

[ ] 8. OWNERSHIP AUDIT (no stale owner entries):

      For each governed registry row, confirm:
      - Function exists in the file
      - Name matches exactly (case-sensitive per project convention)
      - Owner file is still correct after refactors

      If owner moved:
      - Update owner column only
      - Do NOT expand scope

[ ] 9. “NO NEW SURFACE” ASSERTION (final check):

      If code changes were intended to be internal-only, confirm NO new:
      - OnMessage handlers
      - SetTimer calls
      - OnExit hooks
      - process launch / kill paths
      - settings IO interface functions
      - IPC constants, senders, or receivers

      If none added:
      → DO NOT update the governed registry

[ ] 10. REQUIRED OUTPUT (when something changes):

      When a registry-required change is found, write a delta like:
      - ADD: OnMessage 0x1234 → NewHandler (Owner: Worker_Core.ahk) — purpose: <…>
      - ADD: SetTimer(NewTimerCb, 500) (Owner: Main_Worker.ahk) — purpose: <…>
      - MOVE: UpdateWorkerOverlay from Main_Worker.ahk → Worker_Core.ahk
      - MODIFY: WM_TRIGGER_STATE encoding changed → <…> (registry update required)

; ------------------------------------------------------------------
; 3. PHASE 5 AUDIT EXECUTION RUNBOOK (MANDATORY PROCEDURE)
; ------------------------------------------------------------------
PURPOSE:
Execute the Phase 5 audit to deterministically verify that the Observed
Project State exactly matches the Expected Set defined by governance,
with no omissions, additions, or ambiguity.
----
APPLIES WHEN:
A Phase 5 audit is initiated to assert project completeness, structural
correctness, or readiness for declaration of Phase 5 PASS or FAIL.
----
FAILURE RULE(S):
If any Expected Set item is missing from the Observed Set, STOP.
If any Observed item exists outside the Expected Set, STOP.
If any required governance artifact cannot be fully read, STOP.
If tooling limitations prevent deterministic verification, STOP.
; ------------------------------------------------------------------
RUNBOOK STEPS:

[ ] 0. Confirm Phase 5 intent:
      Verify that execution of a Phase 5 audit is explicitly intended
      and not being triggered implicitly by unrelated work or tooling.

[ ] 1. Load authoritative Phase 5 contract:
      Fully read and confirm understanding of:
      GOVERNANCE_COMPENDIUM.txt :: SECTION GOV.S5.PHASE5_AUDIT.

[ ] 2. Establish Expected Set:
      Derive the Expected Set exclusively from:
      - GOVERNANCE_COMPENDIUM.txt :: SECTION GOV.S3.BLUEPRINT
      - All virtual governance sections referenced therein

      Do NOT derive expected items from:
      - directory listings
      - previous audit runs
      - memory
      - tooling heuristics

[ ] 3. Establish Observed Set:
      Enumerate the Observed Project State using deterministic visibility:
      - project root resolution via Bootstrap v4
      - directory and file presence only
      - no inference or extrapolation

[ ] 4. Verify governance artifact readability:
      Confirm full readability and integrity of all required artifacts,
      including but not limited to:
      - GOVERNANCE_COMPENDIUM.txt
      - all required virtual governance sections
      - GLOBAL_REGISTRY_MASTER.csv

[ ] 5. Compare Expected vs Observed (Expected → Observed):
      For each Expected Set item:
      - Confirm it exists in the Observed Set
      - Confirm its path and identity are exact

[ ] 6. Compare Observed vs Expected (Observed → Expected):
      For each Observed item:
      - Confirm it is present in the Expected Set
      - Confirm it is not extraneous or unaccounted for

[ ] 7. Verify Policy-B registry consistency:
      Confirm that all governance-surface elements observed in code
      are represented accurately in GLOBAL_REGISTRY_MASTER.csv.

[ ] 8. Verify mirror and fingerprint integrity:
      Confirm required mirror artifacts exist and that declared
      Content-Fingerprints match observed mirrors where applicable.

[ ] 9. Declare audit result:
      Declare Phase 5 audit outcome as one of:
      - PASS — Observed Set exactly matches Expected Set
      - FAIL — One or more discrepancies detected

      All discrepancies MUST be explicitly recorded if FAIL.

[ ] 10. Enforce outcome:
      If PASS:
      - Phase 5 may be declared complete.

      If FAIL:
      - Do NOT declare Phase 5 complete.
      - Do NOT proceed with dependent actions.
      - Resolve discrepancies before re-running this runbook.

; ------------------------------------------------------------------
; 4. PHASE 5 RESULT DECLARATION RUNBOOK (MANDATORY PROCEDURE)
; ------------------------------------------------------------------
PURPOSE:
Define the mandatory, deterministic format and rules for declaring and
presenting the results of a completed Phase 5 audit.
----
APPLIES WHEN:
A Phase 5 audit execution has completed without STOP conditions and a
formal Phase 5 outcome must be declared or reported.
----
FAILURE RULE(S):
If results cannot be declared using the required format → STOP.
If any classification is ambiguous or inferred → STOP.
If remediation, analysis, or speculation is introduced → STOP.
If Phase 5 execution was incomplete or invalid → STOP.
; ------------------------------------------------------------------
RUNBOOK STEPS:

[ ] 1. Confirm execution eligibility
      - Confirm PROTOCOL_RUNBOOK §3 (Phase 5 Audit Execution) completed
      - Confirm no STOP conditions were encountered
      - Confirm Bootstrap v4 Phases 0–4 succeeded

[ ] 2. Declare report scope
      - State that the report is READ-ONLY
      - State that no remediation or analysis is permitted
      - State that results reflect visibility and structure only

[ ] 3. Emit required metadata
      - Project name
      - Invocation type (explicit user request)
      - Timestamp (UTC)
      - Resolved root Drive ID
      - Resolved root path

[ ] 4. Emit enumeration summary
      - Total folders discovered
      - Total files discovered
      - Total readable files
      - Total unreadable files
      - Total expected-but-missing files
      - Total ungoverned files

[ ] 5. Emit classification sections in order
      - VERIFIED
      - UNREADABLE
      - MISSING
      - ORPHANED
      - UNGOVERNED
      - INDEX DISCREPANCIES
      - ALIAS COVERAGE
      - STRUCTURAL ALIGNMENT

      Each item MUST include:
      - Full path
      - Drive ID (if applicable)
      - Governing source (Blueprint / Index / Registry)
      - Notes (optional, factual only)

[ ] 6. Declare Phase 5 outcome
      - SUCCESS (no blocking issues)
      - DEGRADED (non-blocking issues present)
      - FAILED (blocking issues present)

[ ] 7. Enforce output constraints
      - Do NOT suggest fixes
      - Do NOT infer causes
      - Do NOT modify files
      - Do NOT extend beyond defined sections

[ ] 8. Terminate declaration
      - State Phase 5 declaration complete
      - Await further instruction

; ------------------------------------------------------------------
; 5. GOVERNANCE COMPENDIUM UPDATE RUNBOOK (MANDATORY PROCEDURE)
; ------------------------------------------------------------------
PURPOSE:
Ensure that any modification to GOVERNANCE_COMPENDIUM.txt is performed
atomically, deterministically, and without introducing authority drift,
section ID instability, fingerprint desynchronization, or archival misuse.
----
APPLIES WHEN:
Any change is proposed to GOVERNANCE_COMPENDIUM.txt, including adding,
modifying, rehousing, rewording, or reordering any governance section.
----
FAILURE RULE(S):
If any required verification step fails, STOP.
If any Section ID is modified, reused, or reordered, STOP.
If Content-Fingerprint updates cannot be verified deterministically, STOP.
If archival originals are consulted for enforcement or reasoning, STOP.
; ------------------------------------------------------------------
RUNBOOK STEPS:

[ ] 0. PRE-FLIGHT — Authority confirmation:
      Confirm that GOVERNANCE_COMPENDIUM.txt is the active
      single-artifact governance authority.
      Confirm no parallel governance source is being referenced.

[ ] 1. SCOPE DECLARATION — Identify the change class:
      Explicitly classify the change as ONE of the following:
      - Add new section
      - Modify existing section
      - Rehouse content between sections
      - Clarify wording without semantic change

      If more than one class applies → STOP and split the change.

[ ] 2. SECTION ID SAFETY CHECK:
      Verify that:
      - All existing Section IDs remain unchanged
      - No Section ID is renamed, reused, or repurposed
      - No Section ID ordering is altered unless explicitly structural

      Section IDs are immutable identities.
      Violations here are unrecoverable.

[ ] 3. ARCHIVED ORIGINALS BOUNDARY CHECK:
      Confirm that:
      - Archived original governance files (under /Archive)
        are used ONLY for:
          - historical reference
          - literal fidelity comparison
      - Archived originals are NOT used for:
          - enforcement
          - reasoning
          - justification
          - conflict resolution

      If any archived content influences decisions → STOP.

[ ] 4. OPERATIVE TEXT UPDATE:
      Perform the required edit within:
      GOVERNANCE_COMPENDIUM.txt :: SECTION <TARGET_SECTION>

      Rules:
      - Maintain MAINTEMPLATE header
      - Update Version and Last change appropriately
      - Do NOT summarize or paraphrase unrelated content
      - Preserve all unchanged content verbatim

[ ] 5. CONTENT-FINGERPRINT UPDATE:
      Regenerate the Content-Fingerprint for the modified section.

      Verify:
      - Timestamp is UTC
      - Suffix is exactly 8 characters
      - Format matches governance specification

      If fingerprint cannot be regenerated deterministically → STOP.

[ ] 6. CROSS-SECTION CONSISTENCY CHECK:
      Scan for references to the modified section in:
      - GOV.S1.AI_INSTRUCTIONS
      - GOV.S2.BOOTSTRAP_V4
      - GOV.S3.BLUEPRINT
      - GOV.S7.INDEX_ID_LIST
      - PROTOCOL_RUNBOOK.txt

      This list represents authority-bearing dependency hubs; other sections need only be scanned if the change directly affects their stated scope.
      If any reference is now stale or contradictory → STOP.

[ ] 7. STRUCTURAL IMPACT CHECK:
      If the change affects:
      - structure
      - authority hierarchy
      - bootstrap behavior
      - registry interaction

      Then confirm required synchronization updates are staged
      (Blueprint / Anchor / Registry where applicable).

[ ] 8. FINAL READABILITY VERIFICATION:
      Re-open GOVERNANCE_COMPENDIUM.txt and confirm:
      - File is fully readable
      - No section is truncated
      - All required sections remain present

[ ] 9. DECLARATION:
      Declare the update complete ONLY after all steps pass.
      Resume project work.

; ------------------------------------------------------------------
; 6. REGISTRY REGENERATION & VALIDATION RUNBOOK (MANDATORY PROCEDURE)
; ------------------------------------------------------------------
PURPOSE:
Safely regenerate and validate non-governed registry artifacts while
preventing accidental modification, expansion, or erosion of
Policy-B governed surface area.
----
APPLIES WHEN:
The INTERNAL_FUNCTION_INDEX.csv is regenerated, refreshed, validated,
or audited for completeness, accuracy, or drift.
----
FAILURE RULE(S):
If any Policy-B governed surface area is added, removed, or modified, STOP.
If GLOBAL_REGISTRY_MASTER.csv is altered as part of regeneration, STOP.
If regeneration cannot be proven non-governance-impacting, STOP.
; ------------------------------------------------------------------
RUNBOOK STEPS:

[ ] 0. PRE-FLIGHT — Registry role confirmation:
      Confirm the distinct roles of registry artifacts:
      - GLOBAL_REGISTRY_MASTER.csv → Policy-B authoritative (governed)
      - INTERNAL_FUNCTION_INDEX.csv → Informational, regenerable (non-governed)

      Confirm that regeneration will be performed by a deterministic
      tool or script, not by inference or interpretation.

      If scope boundaries or execution method are unclear → STOP.

[ ] 1. SCOPE DECLARATION — Regeneration intent:
      Explicitly declare the purpose of regeneration as ONE of:
      - Symbol discovery
      - Navigation support
      - Refactor assistance
      - Drift inspection

      If the intent involves enforcement, authority, invariants,
      or classification → STOP.

[ ] 2. GOVERNED SURFACE GUARD:
      Before regeneration, confirm that NO changes are being proposed to:
      - Entrypoints
      - Timers (SetTimer callbacks)
      - OnMessage / IPC handlers
      - IPC message encodings
      - Settings IO or defaults interface
      - Lifecycle or process controls

      If any governed surface change exists:
      → STOP and invoke the Policy-B Registry Audit Runbook instead.

[ ] 3. REGENERATION EXECUTION:
      Regenerate INTERNAL_FUNCTION_INDEX.csv using the chosen
      deterministic method.

      Rules:
      - No inference or heuristic classification
      - No ownership, authority, or risk labeling
      - No filtering based on perceived importance

      This step is mechanical only.

[ ] 4. POST-GENERATION VALIDATION:
      Verify that the regenerated index:
      - Contains only symbol inventory (functions, classes, helpers)
      - Does NOT introduce governance semantics
      - Does NOT redefine ownership, authority, scope, or invariants

      If any ambiguity or implied authority exists → STOP.

[ ] 5. POLICY-B INTEGRITY CHECK:
      Re-open GLOBAL_REGISTRY_MASTER.csv and confirm:
      - No rows were added, removed, or modified
      - No scope expansion occurred
      - Policy-B surface remains unchanged

      If any discrepancy is detected → STOP.

[ ] 6. OPTIONAL DRIFT REVIEW (NON-BINDING):
      Differences observed between:
      - INTERNAL_FUNCTION_INDEX.csv
      - Codebase symbols

      MAY be noted for refactor or cleanup planning ONLY.

      These observations MUST NOT:
      - Trigger registry edits
      - Trigger governance changes
      - Be treated as enforcement signals

[ ] 7. FINAL CONFIRMATION:
      Confirm regeneration is complete.
      Resume normal project work.

; ------------------------------------------------------------------
; 7. PLC EXTERNALIZATION & EMISSION RUNBOOK (MANDATORY PROCEDURE)
; ------------------------------------------------------------------
PURPOSE:
Ensure Project Learned Constraints (PLC) are recorded deterministically,
confirmed explicitly, stored in a scalable standalone file, and kept
non-divergent from the compendium view while remaining non-authoritative.
----
APPLIES WHEN:
A new constraint is discovered, an approach is invalidated, or a
confirmed limitation must be recorded to prevent regression.
----
FAILURE RULE(S):
If a PLC entry is added without explicit confirmation, STOP.
If PLC format or scope taxonomy is altered, STOP.
If PLC content is treated as authoritative or enforcement-capable, STOP.
If compendium PLC content diverges from the canonical PLC file, STOP.
; ------------------------------------------------------------------
RUNBOOK STEPS:

[ ] 0. PRE-FLIGHT — Confirm PLC role:
      PLCs are institutional memory only.
      PLCs MUST NOT override governance, bootstrap, runbooks, or registry.

[ ] 1. CANONICAL FILE CHECK:
      Confirm canonical PLC file exists:
      Pipz_Project_V3\Governance\PROJECT_LEARNED_CONSTRAINTS.txt

      If missing → STOP and create it via a governed file creation step.

[ ] 2. DRAFT ENTRY (NO WRITES):
      Draft a complete PLC entry using the strict PLC format:
      - ENTRY ID (placeholder only)
      - DATE (UTC)
      - SCOPE (exactly one, from canonical taxonomy)
      - STATUS
      - TITLE
      - CONTEXT
      - DISCOVERY
      - INVALIDATED APPROACH
      - VALIDATED CONSTRAINT
      - EVIDENCE
      - RELATED FILES
      - NOTES

      Present the draft for explicit accept / reject.

[ ] 3. CONFIRMATION GATE:
      If the draft is rejected → STOP and discard.
      If accepted → proceed.

[ ] 4. ID ASSIGNMENT:
      Assign the next sequential PLC-#### identifier.
      IDs are monotonic and MUST NOT be reused.

[ ] 5. COMMIT (APPEND ONLY):
      Append the confirmed entry below the append-only boundary
      in PROJECT_LEARNED_CONSTRAINTS.txt.

      Existing entries MUST NOT be edited or reordered.
      Status changes require explicit STATUS updates only.

[ ] 6. SCOPE INDEX UPDATE:
      Update the scope index to include the new PLC ID.
      If a new scope is required, add it to the taxonomy explicitly.

[ ] 7. COMPENDIUM SYNC (IF SNAPSHOT PRESENT):
      If GOV.S8 includes a snapshot:
      - Copy entries mechanically from the canonical PLC file
      - Update the “Last Synced (UTC)” marker
      - Do NOT summarize or reinterpret content

[ ] 8. FINAL VERIFICATION:
      Confirm:
      - Canonical PLC file contains the new entry
      - Scope index is accurate
      - Compendium snapshot (if present) matches canonical
      - No authority claims were introduced

      Resume normal project work.

; ------------------------------------------------------------------
; 8. PUBLISHER BUNDLE & POINTER EMISSION RUNBOOK (MANDATORY PROCEDURE)
; ------------------------------------------------------------------
PURPOSE:
Deterministically publish a project context bundle and update `PIPZ_POINTER.txt` so that the current project snapshot can be retrieved reliably for AI visibility without ambiguity or silent drift.
---
APPLIES WHEN:
A project context bundle is being published via the `pipz-publisher` VS Code extension to update the current authoritative snapshot referenced by `PIPZ_POINTER.txt`.
---
FAILURE RULE(S):
If `PIPZ_POINTER.txt` is missing required fields (BUNDLE_URL or BUILD_ID) → STOP.
If the referenced bundle asset cannot be retrieved end-to-end from BUNDLE_URL → STOP.
If pointer BUILD_ID does not match bundle BUILD_ID → STOP.
If MANIFEST.json is missing from the bundle or cannot be read → STOP.
If the bundle contents do not include all allowlist-authoritative directories required by the current publisher configuration (e.g. Registry/, PPAVP/ when included) → STOP.
If MANIFEST_SHA256 recorded in `PIPZ_POINTER.txt` does not match the locally generated MANIFEST.json for the publish run → STOP.
; ------------------------------------------------------------------
RUNBOOK STEPS:

[ ] 0. Confirm publish intent and workspace target.
      Verify the correct project workspace is open and targeted for publishing.

[ ] 1. Trigger publish via `pipz-publisher`.
      Invoke the publish command (hotkey or command palette) and allow it to complete.

[ ] 2. Verify local output artifacts exist for this publish run.
      Confirm presence of:
      - `.pipz_publish_out/BUILD_ID.txt`
      - `.pipz_publish_out/MANIFEST.json`
      - `.pipz_publish_out/<releaseAssetName>.zip` (default: `pipz-context-latest.zip`)

[ ] 3. Verify allowlist coverage within the produced bundle.
      Open the bundle zip and confirm it includes all allowlist-authoritative directories required by current configuration (e.g. `Registry/`, `PPAVP/` if configured).

[ ] 4. Verify GitHub Release asset presence and retrieval.
      Confirm the Release tag exists (default: `context-latest`), the asset is present, and the asset is downloadable end-to-end.

[ ] 5. Verify pointer emission occurred and fields are present.
      Open `Governance/PIPZ_POINTER.txt` and confirm it contains:
      - `BUNDLE_URL`
      - `BUILD_ID`
      - `BASE_COMMIT_SHA`
      - `WORKTREE_STATE`
      - `MANIFEST_SHA256`

[ ] 6. Enforce determinism gate for the publish run.
      Confirm:
      - `BUILD_ID` in pointer matches `BUILD_ID.txt`
      - `BUNDLE_URL` resolves to the newly uploaded asset
      - `MANIFEST_SHA256` corresponds to the locally generated MANIFEST.json for this run

[ ] 7. Record completion and proceed.
      Treat the published bundle referenced by `PIPZ_POINTER.txt` as the current snapshot for AI visibility until superseded by a later publish run.

; ------------------------------------------------------------------

END OF PROTOCOL RUNBOOK