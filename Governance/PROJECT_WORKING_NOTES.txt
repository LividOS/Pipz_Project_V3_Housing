; ------------------------------------------------------------------
; GEMINI MEM TAG (DO NOT EVER REMOVE OR EDIT)
; MY FULL PATH IS "Pipz_Project_V3\Governance\PROJECT_WORKING_NOTES.txt"
; ------------------------------------------------------------------

; ------------------------------------------------------------------
; MAINTEMPLATE - PROJECT_WORKING_NOTES.txt
; Version: 1.0.3
; Last change: Instated canonical mandatory entry formatting guidelines.
; Content-Fingerprint: 2026-02-03T18-44-15Z-X4HBLGAK
; ------------------------------------------------------------------

; ------------------------------------------------------------------
; ALL CONTENT MUST GO BELOW THIS POINT (LINES 1–14 RESERVED)
; ------------------------------------------------------------------

; ------------------------------------------------------------------
NON-AUTHORITATIVE NOTICE (MANDATORY)
; ------------------------------------------------------------------

This file records project design intent, architectural rationale,
guardrails, and long-form working notes for Pipz_Project_V3.

This file is NOT authoritative.

It does NOT:
- Define governance rules
- Override GOVERNANCE_COMPENDIUM.txt
- Override PROTOCOL_RUNBOOK.txt
- Override bootstrap requirements
- Override registry invariants

This file exists to preserve context and intent over time.

; ------------------------------------------------------------------
PROJECT WORKING NOTES (DESIGN & RATIONALE)
; ------------------------------------------------------------------

PURPOSE OF THIS FILE
--------------------
This document exists to preserve:
- Design intent
- Non-obvious decisions
- Sanity checks
- “Why we did it this way”
- Guardrails against future regression

This file is NOT a checklist.
This file is NOT expected to be concise.
This file SHOULD grow over time.

; ------------------------------------------------------------------
CANONICAL NOTE FORMATTING (MANDATORY)
; ------------------------------------------------------------------

This formatting standard applies to all entries in
PROJECT_WORKING_NOTES.txt only.

It exists to preserve consistency, readability, and historical clarity.
It does NOT introduce governance authority and does NOT apply to
governance documents, PLCs, registries, or runbooks.

Format:

[YYYY-MM-DD]
- ID:
- Decision:
- Reason:
- Impact:

ID NOTES:
- IDs are local to this file only.
- IDs are sequential and informational.
- IDs do NOT imply authority, precedence, or enforcement.

; ------------------------------------------------------------------
CORE GOALS (DO NOT LOSE SIGHT OF THESE)
; ------------------------------------------------------------------

1. The user interacts with ONE assistant only (Architect).
2. All other AI roles are hidden, automated, and auditable.
3. Governance is enforced by code, not “AI good behavior.”
4. Drift is mechanically impossible, not just unlikely.
5. Every change is attributable, reviewable, and reversible.

If any future change weakens these goals, STOP.

; ------------------------------------------------------------------
WHY SIDECAR GOVERNANCE EXISTS
; ------------------------------------------------------------------

Some file formats are controlled by external tools:
- JSON
- lockfiles
- generated artifacts
- binaries

Governance MUST NEVER break tooling.

Therefore:
- Governance metadata moves to sidecar files
- Sidecars are authoritative
- Runtime artifacts remain pure

This is not a compromise — it is intentional architecture.

; ------------------------------------------------------------------
WHY NOT RELY ON CONTINUE / BUILT-IN AGENTS ALONE
; ------------------------------------------------------------------

Continue is powerful, but:
- It does not natively enforce hidden multi-model chaining
- It cannot prevent a model from “doing too much”
- It cannot hard-enforce mirroring or fingerprint rules

Therefore:
- Continue is treated as the Architect UI only
- Enforcement lives outside the model
- MCP / orchestrator handles invariants

; ------------------------------------------------------------------
ROLE SEPARATION INTENT
; ------------------------------------------------------------------

Architect:
- Thinks
- Plans
- Explains
- Is the ONLY user-facing AI
- NEVER writes directly

Executor:
- Implements literally
- No opinions
- No creativity
- Outputs full files by default

SubSupervisor:
- Mechanical checklist
- Objective PASS / FAIL
- Cannot be overridden

HeadSupervisor:
- Semantic correctness
- Architectural intent validation
- Risk detection
- Cannot override mechanical failure

; ------------------------------------------------------------------
RECENT KEY DECISIONS (IMPORTANT CONTEXT)
; ------------------------------------------------------------------

[2026-01-22]
- ID: 0001
- Decision: Introduced an MVP orchestrator with bootstrap-only behavior.
- Reason: Establish a safe, runnable baseline to validate governance, bootstrap, and audit flows before enabling hidden role chaining or execution authority.
- Impact:
  - Orchestrator performs verification and audit initialization only.
  - No model calls or file writes are permitted at this stage.
  - Governance and tooling assumptions could be validated early without risk.

[2026-01-22]
- ID: 0002
- Decision: Finalized JSON governance via mandatory sidecar files.
- Reason: JSON does not support comments and is parsed by strict toolchains; embedding headers or governance metadata directly would break tooling.
- Impact:
  - Introduced mandatory sidecar files (e.g., package.json.governance.txt, tsconfig.json.governance.txt).
  - JSON runtime artifacts remain pure and tooling-safe.
  - Governance metadata is enforced without compromising external parsers.

[2026-01-23]
- ID: 0003
- Decision: Completed port of MirrorAhkToTxt functionality into a VS Code extension.
- Reason: File mirroring, fingerprinting, and audit enforcement needed to operate continuously within the normal developer environment rather than as an external script.
- Impact:
  - Fingerprint updates enforced on save with fail-closed gating.
  - Runtime mirroring (.ahk/.ini → .txt) implemented with AI SOT headers.
  - Standalone governed fingerprinting enabled for additional file types.
  - UTF-8 and UTF-16 mirror encoding compatibility implemented.
  - Audit logging written to .ORCH_AUDITLOG\mirror\.
  - Extension packaged (VSIX) and installed into normal VS Code.

[2026-01-23]
- ID: 0004
- Decision: Documented and resolved VS Code Extension Development Host limitations.
- Reason: The Extension Development Host exhibited behavior inconsistent with the real user environment, risking false confidence during testing.
- Impact:
  - Identified inability of Dev Host to reliably open folders/workspaces.
  - DisposableStore disposal warnings were observed and investigated.
  - Development and validation workflows were adjusted to prioritize testing in normal VS Code.

[2026-02-03]
- ID: 0005
- Decision: Externalized Project Learned Constraints into a standalone canonical file.
- Reason: The learned constraints list was expected to grow indefinitely and did not belong in the governance compendium long-term. A standalone, append-only file allows scalability without introducing shadow authority.
- Impact:
  - PROJECT_LEARNED_CONSTRAINTS.txt is now the canonical PLC store.
  - GOV.S8.LEARNED_CONSTRAINTS was converted to a pointer + optional snapshot.
  - Learned constraints are now clearly separated from governance authority.

[2026-02-03]
- ID: 0006
- Decision: Formalized a dedicated PLC Externalization & Emission Runbook.
- Reason: PLC creation needed a deterministic, auditable process to prevent silent constraint drift or retroactive rationalization.
- Impact:
  - New PLC entries require explicit confirmation and strict formatting.
  - PLCs are append-only, non-authoritative, and scope-indexed.
  - PLC emission is now mechanically governed rather than discretionary.

[2026-02-03]
- ID: 0007
- Decision: Externalized GOV.S4 Section B (Project Working Notes) into a standalone file.
- Reason: Section B was explicitly designed to grow over time and contained narrative rationale, which conflicted with the compendium’s role as a stable single-artifact authority.
- Impact:
  - PROJECT_WORKING_NOTES.txt introduced as a non-authoritative, append-only rationale log.
  - GOV.S4.ANCHOR_MASTER now contains only stable anchor content and a pointer stub.
  - Compendium growth pressure reduced without loss of context.

[2026-02-03]
- ID: 0008
- Decision: Clarified “single-artifact mode” semantics in the Blueprint.
- Reason: The original wording implied no external governance-adjacent files could exist, which became false after introducing canonical support artifacts (PLCs, working notes, runbooks).
- Impact:
  - Blueprint now distinguishes authoritative governance from non-authoritative canonical support artifacts.
  - Phase-5 Expected Set logic remains deterministic and unambiguous.

[2026-02-03]
- ID: 0009
- Decision: Standardized alias resolution to distinguish constraint indexes from canonical constraint storage.
- Reason: Overlapping aliases between GOV.S8 and PROJECT_LEARNED_CONSTRAINTS.txt risked semantic ambiguity for both humans and tooling.
- Impact:
  - GOV.S8 aliases now resolve to an index/gateway role only.
  - Canonical constraint terminology maps exclusively to the standalone PLC file.
  - Future automation and search behavior is safer and deterministic.

; ------------------------------------------------------------------
COMMON FAILURE MODES TO WATCH FOR
; ------------------------------------------------------------------

- “We’ll remember to do X later” → NO
- “This file doesn’t need governance” → PROVE IT
- “The AI probably won’t touch that” → INVALID ASSUMPTION
- Silent tool behavior changes
- Header drift
- JSON acquiring comments (must remain pure)

; ------------------------------------------------------------------
WHEN TO STOP AND REASSESS
; ------------------------------------------------------------------

STOP if:
- Determinism is weakened
- Governance is bypassed
- Memory replaces enforcement
- Manual role switching is required
- Audit logs degrade

; ------------------------------------------------------------------
VS CODE EXTENSION REPACKAGING – DESIGN RATIONALE
; ------------------------------------------------------------------

The pipz-mirror-governance extension is not “just a tool”.
It is an ACTIVE GOVERNANCE ENFORCER.

Therefore:

- Any change to it can silently weaken guarantees if not rebuilt correctly
- VS Code does NOT auto-reload packaged extensions
- Extension Development Host ≠ real user environment

Because of this, a strict VSIX repackaging runbook was introduced.

Key principles enforced by the runbook:

1. BUILD IS EXPLICIT
   No implicit TypeScript transpilation is trusted.

2. INSTALL IS EXPLICIT
   The extension must be installed into the NORMAL VS Code instance,
   not assumed to be active because Dev Host worked.

3. VERIFICATION IS MANDATORY
   Mirroring, fingerprinting, encoding, and audit logging must be
   observed in real saves.

4. NO SILENT FAILURE
   If the extension fails to activate or log, work stops immediately.

This mirrors the broader project philosophy:

- Trust code, not memory
- Trust logs, not assumptions
- Trust enforcement, not intent

This runbook is deliberately repetitive and procedural.
That is a feature, not a flaw.

; ------------------------------------------------------------------
FUTURE NOTES
; ------------------------------------------------------------------

(Add dated notes below as decisions are made.)

; ------------------------------------------------------------------
END OF PROJECT WORKING NOTES
; ------------------------------------------------------------------